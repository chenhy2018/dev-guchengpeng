最大素数问题
====

* 输入：一个 3 - 2^32 的整数 N
* 输出：小于 N 的最大素数，以及程序中所有if语句（含if、switch、for循环条件）的总执行次数。
* 要求：
 1. 用 Go 语言；
 2. 不允许调用任何标准库或者第三方库，但允许用 builtin 函数，比如 make、println。

## 最佳3个答案（排名不分先后）

### 1. 最正统答案

实现者：

* 李瑞奇
* 刘坚君

把问题分解为两步：

1）找到所有 < sqrt(N) 的素数。这一步如何减少比较次数有较大优化空间。示范代码：

```go
var (
	primes []uint64
	limit uint64
	n int
)

func init() {
	primes = make([]uint64, 2, 1024)
	primes[0] = 2
	primes[1] = 3
	n = 1
	limit = uint64(9)
}

func isPrime(v uint64) bool {
	for i := 0; i < n; i++ {
		if v % primes[i] == 0 {
			return false
		}
	}
	return true
}

func listPrimes(N uint64) {

	v := uint64(5)

loop:
	for v < limit {
		if isPrime(v) {
			primes = append(primes, v)
			if v * v >= N {
				return
			}
		}
		v += 2
	}
	v += 2
	n++
	limit = primes[n] * primes[n]
	goto loop
}
```

2）从 N 开始倒序找到第一个素数（判断是否素数需要用到第一步的结果）。这一步的优化比较平凡。

```go
func maxPrimeOf(N uint64) uint64 {

	n = len(primes)

	if (N&1) == 0 {
		N--
	}
	for {
		if isPrime(N) {
			return N
		}
		N -= 2
	}
}
```

### 2. 常规优化思路

实现者：

* 范辰麟
* 李兆海

本质上思路和上面答案1一样，但是对步骤一进行优化。由于已知 N <= 2^32，从而 sqrt(N) <= 2^16。所以我们只需要内置一个所有 < 2^16 的素数表，就可以把步骤一的开销省掉。

成本分析：< 2^16 的素数量非常少，内存开销很低。并且答案1在最差情况下也有一样的内存开销，所以本次优化几乎可以认为无成本。

代码略。

### 3. 非常规优化

有两种非常规优化思路：

思路(1)：

实现者：

* 徐兆魁

建立一个 3 ~ 2^32 这些数据是否素数的 bitmap，然后通过找到 bitmap 里面距离 N 这个 bit 的 1 来找到最大素数。由于可以将 bitmap 看做是 uint64 数组，所以我们可以先找一个非 0 的 uint64，然后进一步去看 uint64 里面的 bit。

成本分析：显然，内存需求是 2^31 bits = 2^28 bytes，即 256M。

效果分析：我们相比上面的答案2进行分析。上面答案2的步长是2（每个步长下还有 isPrime 函数调用，有较多次数的 if 判断），这里的步长是64（且单步里面没有额外if判断）。故此该算法效果是if调用次数最保守估计至少能够降低到原来的 1/32 次。


思路(2)：

实现者：

* 不详（找不到邮件了，请自己站出来 ^_^）

直接建立 N => prime 的映射表。这样只需要一次 map 的查找即得到答案。

成本分析：映射的每一项数据是 8 字节。如果是开链法，还需要一个 8 字节指针，所以成本为： 16 * 2^31 (偶数可以优化掉) = 32G (通过优化映射的表示，可以进一步优化内存开销，极限是到 16G)。


## 为什么不做排名

不同的算法，脱离应用场景，很难比较优劣。因为在不同应用场景下，对资源的要求很可能有非常巨大的差异。

答案3的这些非常规优化是有效的，但是也为此付出了更高的存储成本。

答案2无论从何种角度来说都胜过答案1，但这仅仅只在本题目的前提下有效。如果把 N < 2^32 的约束条件去掉，把它看做是一个开放性问题，那么答案1灵活性优势就立刻体现出来。

这并不是说我们不该去思考特定场景下的优化，相反我们应该鼓励结合特定应用场景下的优化手段。但做这样的优化之前，我们一定要努力尝试去预见未来
的变化：也就是判断应用场景的预设条件的合理性。如果可以预见到未来可能某个假设条件会被破坏，那么这样的优化手段就应谨慎使用。


## 部分答案点评

### 减少if调用的一些方法

1、用算式取代if

比如将

```go
if (N&1) == 0 {
	N--
}
```

改为：

```go
N = N - (1 - (N & 1))
```

点评：应当承认这样的改法确实是有效的，程序效能会有细微的提升。但是在绝大多数情况下来说，这只是一种过度优化，因为核心瓶颈通常不在这里。

2、用 || 或 && 的短路效果取代 if

比如将

```go
if cond {
	expr
}
```

改为：

```go
cond && func() bool { expr; return true } ()
```

点评：换汤不换药。如果我们把 if 调用次数看做 KPI 的话，这是典型的 KPI 驱动下的做事结果。它能够让我们清楚看到，KPI 好的结果，实际则未必真好。如果我们把 KPI 换成程序的执行时间尽可能短，那么结果就可能是完全另一个样子了。

启发：对于项目经理来说，设置合适的评估指标非常重要。对于项目普通成员来说，透过 KPI 去理解直至确认正真的用意，远比盲目优化 KPI 重要。

### if 调用次数统计的正确性

if 调用次数统计的代码正确性之低，远远出乎我的意料。有些同学干脆没有统计，大部分同学则统计非常不严谨。

非核心问题往往容易被人遗忘，这在这么小的一个问题上，就能够体现出不同人的差异来。

这里要表扬两个人：

* 郑李新
* 马伟伟

他们两对这样一个问题处理的严谨态度，是非常值得学习的。马伟伟甚至创造了一个很有趣的统计方法：

```go
var g_count int

func count() bool {
	g_count++
	return false
}
```

然后：

```go
if count() || cond {
	expr
}

for count() || cond {
	expr
}
```

就可以无脑做 if 调用的统计了。
